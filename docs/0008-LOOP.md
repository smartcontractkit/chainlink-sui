# LOOP Plugin Architecture in Chainlink-Sui

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [LOOP Plugin Overview](#loop-plugin-overview)
3. [Sui-Specific Implementation](#sui-specific-implementation)
4. [Data Encoding/Decoding Challenges](#data-encodingdecoding-challenges)
5. [Architecture Components](#architecture-components)
6. [Code References](#code-references)
7. [Key Implementation Details](#key-implementation-details)
8. [Benefits and Trade-offs](#benefits-and-trade-offs)
9. [Issues & Concerns](#issues-and-concerns)
10. [Recommended Improvements](#recommended-improvements)
11. [Impact Assessment](#impact-assessment)

## Executive Summary

The LOOP (Local Out-Of-Process Plugin) architecture represents a fundamental shift in how Chainlink Core Node integrates with different blockchain networks. For Sui, this architecture provides process-level isolation, enhanced security, and decoupled release cycles while addressing the unique challenges of JSON serialization across process boundaries.

## LOOP Plugin Overview

LOOP plugins are based on HashiCorp's `go-plugin` library and enable out-of-process execution of chain-specific relayers. The architecture separates the core Chainlink node from individual blockchain integrations, providing:

- **Process Isolation**: Each blockchain integration runs in its own process
- **Enhanced Security**: Failures in one chain don't affect others or the core node
- **Independent Release Cycles**: Chain plugins can be updated without core node restarts
- **Reduced Dependencies**: Core node no longer imports all chain-specific dependencies
- **Scalability**: Support for multi-chain configurations with lower risk

### Core Components

The LOOP architecture consists of several key components:

1. **LOOP Server**: Manages the plugin lifecycle and gRPC communication
2. **Plugin Relayer**: Chain-specific implementation of relayer interfaces
3. **gRPC Protocol**: Communication bridge between core node and plugin
4. **Wrapper Interfaces**: Adaptation layers for data serialization

## Sui-Specific Implementation

### Main Entry Point

The Sui LOOP plugin entry point is defined in `relayer/cmd/chainlink-sui/main.go`:

```go
func main() {
    s := loop.MustNewStartedServer(loggerName)
    defer s.Stop()

    p := &pluginRelayer{Plugin: loop.Plugin{Logger: s.Logger}}
    defer s.Logger.ErrorIfFn(p.Close, "Failed to close")

    s.MustRegister(p)

    stopCh := make(chan struct{})
    defer close(stopCh)

    plugin.Serve(&plugin.ServeConfig{
        HandshakeConfig: loop.PluginRelayerHandshakeConfig(),
        Plugins: map[string]plugin.Plugin{
            loop.PluginRelayerName: &loop.GRPCPluginRelayer{
                PluginServer: p,
                BrokerConfig: loop.BrokerConfig{
                    StopCh:   stopCh,
                    Logger:   s.Logger,
                    GRPCOpts: s.GRPCOpts,
                },
            },
        },
        GRPCServer: s.GRPCOpts.NewServer,
    })
}
```

### Plugin Relayer Implementation

The `pluginRelayer` struct implements the `loop.PluginRelayer` interface and serves as the factory for creating Sui relayer instances:

```go
func (c *pluginRelayer) NewRelayer(ctx context.Context, config string, keystore loop.Keystore, capRegistry core.CapabilitiesRegistry) (loop.Relayer, error) {
    d := toml.NewDecoder(strings.NewReader(config))
    d.DisallowUnknownFields()

    var cfg config2.TOMLConfig
    if err := d.Decode(&cfg); err != nil {
        return nil, fmt.Errorf("failed to decode config toml: %w:\n\t%s", err, config)
    }

    // Validation and relayer creation
    relayer, err := suiplugin.NewRelayer(&cfg, c.Logger, keystore)
    if err != nil {
        return nil, fmt.Errorf("failed to create relayer: %w", err)
    }

    c.SubService(relayer)
    return relayer, nil
}
```

## Data Encoding/Decoding Challenges

### The JSON Marshalling Problem

When running as a LOOP plugin, all data must cross process boundaries via gRPC, which requires JSON serialization. This creates several challenges:

1. **Type Loss**: JSON unmarshalling loses specific Go type information
2. **Numeric Precision**: Large integers may be converted to `json.Number` or `float64`
3. **Complex Type Mapping**: Sui-specific types need special handling

### Chain Reader Adaptations

The Sui chain reader includes specific logic to handle LOOP plugin mode, as seen in `relayer/chainreader/chainreader.go`:

```go
// If we're running as a LOOP plugin, we need to unmarshal the params as JSON
if s.config.IsLoopPlugin {
    paramBytes := params.(*[]byte)

    // TODO: do we need this? use json.Number to preserve numeric precision
    decoder := json.NewDecoder(bytes.NewReader(*paramBytes))
    decoder.UseNumber()

    err := decoder.Decode(&argMap)
    if err != nil {
        return fmt.Errorf("failed to unmarshal JSON params: %+w", err)
    }

    // Convert JSON-unmarshaled values back to proper Go types using existing encoder
    convertedArgMap := make(map[string]any)
    if functionConfig.Params != nil {
        for _, paramConfig := range functionConfig.Params {
            if jsonValue, exists := argMap[paramConfig.Name]; exists {
                // we encode because when we unmarshal the params as JSON, we get a json.Number
                // which is a string representation of a number. We need to convert it to the proper
                // Go type.
                convertedValue, err := codec.EncodeToSuiValue(paramConfig.Type, jsonValue)
                if err != nil {
                    return fmt.Errorf("failed to convert parameter %s of type %s: %w", paramConfig.Name, paramConfig.Type, err)
                }
                convertedArgMap[paramConfig.Name] = convertedValue
            }
        }
    }
    argMap = convertedArgMap
}
```

### Return Value Serialization

When operating as a LOOP plugin, return values must be marshalled back to JSON:

```go
if s.config.IsLoopPlugin {
    // Marshall the data as JSON for LOOP compatibility
    resultBytes, err := json.Marshal(valueField)
    if err != nil {
        return fmt.Errorf("failed to marshal data for LOOP: %+w", err)
    }
    returnValPtr, ok := returnVal.(*[]byte)
    if !ok {
        return fmt.Errorf("return value is not a pointer to []byte as expected when running as a LOOP plugin")
    }
    *returnValPtr = make([]byte, len(resultBytes))
    copy(*returnValPtr, resultBytes)

    return nil
}
```

### LOOP Chain Reader Wrapper

The `relayer/chainreader/loop/loop_reader.go` implements a wrapper that handles the JSON serialization/deserialization automatically:

```go
func (s *loopChainReader) GetLatestValue(ctx context.Context, readIdentifier string, confidenceLevel primitives.ConfidenceLevel, params, returnVal any) error {
    convertedResult := []byte{}

    jsonParamBytes, err := json.Marshal(params)
    if err != nil {
        return fmt.Errorf("failed to marshal params: %+w", err)
    }

    // we always bind before calling query functions, because the LOOP plugin may have restarted.
    err = s.reader.Bind(ctx, s.getBindings())
    if err != nil {
        return fmt.Errorf("failed to re-bind before GetLatestValue: %w", err)
    }

    err = s.reader.GetLatestValue(ctx, readIdentifier, confidenceLevel, &jsonParamBytes, &convertedResult)
    if err != nil {
        return fmt.Errorf("failed to call GetLatestValue over LOOP: %w", err)
    }

    err = s.decodeGLVReturnValue(readIdentifier, convertedResult, returnVal)
    if err != nil {
        return fmt.Errorf("failed to decode GetLatestValue return value: %w", err)
    }

    return nil
}
```

## Architecture Components

### Configuration Management

The `relayer/chainreader/config.go` defines the configuration structure with the critical `IsLoopPlugin` flag:

```go
type ChainReaderConfig struct {
    IsLoopPlugin bool
    Modules      map[string]*ChainReaderModule
}
```

This flag determines the execution mode and triggers different encoding/decoding paths.

### Codec Adaptations

The `relayer/codec/decoder.go` includes special handling for large integers to ensure JSON compatibility:

```go
case responseType == "u128" || responseType == "u256":
    // For large uints, return as *big.Int so JSON marshaling works correctly in LOOP mode
    if byteArray, ok := responseValue.([]any); ok {
        // Convert byte array to big.Int (little-endian)
        result := new(big.Int)
        bytesArray, err := AnySliceToBytes(byteArray)
        if err != nil {
            return nil, err
        }
        result.SetBytes(bytesArray)
        return result, nil
    }
```

### Query Expression Serialization

For complex query operations, the `relayer/chainreader/loop/loop_query.go` handles serialization of query expressions:

```go
func SerializeExpressions(exprs []query.Expression) ([]query.Expression, error) {
    serializedExprs := make([]query.Expression, 0, len(exprs))
    for _, expr := range exprs {
        serializedExpr, err := serializeExpressionValues(expr)
        if err != nil {
            return nil, fmt.Errorf("failed to serialize expression: %w", err)
        }
        serializedExprs = append(serializedExprs, serializedExpr)
    }
    return serializedExprs, nil
}
```

## Code References

### Key Files and Their Roles

1. **Main Entry Point**: [`relayer/cmd/chainlink-sui/main.go`](../relayer/cmd/chainlink-sui/main.go)
   - Initializes LOOP server
   - Configures gRPC communication
   - Registers plugin relayer

2. **Plugin Relayer**: [`relayer/plugin/relayer.go`](../relayer/plugin/relayer.go)
   - Implements core relayer interfaces
   - Creates chain readers and writers
   - Manages Sui-specific functionality

3. **Chain Reader Implementation**: [`relayer/chainreader/chainreader.go`](../relayer/chainreader/chainreader.go)
   - Handles blockchain data reading
   - Includes LOOP-specific encoding/decoding logic
   - Manages parameter and return value serialization

4. **LOOP Wrapper**: [`relayer/chainreader/loop/loop_reader.go`](../relayer/chainreader/loop/loop_reader.go)
   - Provides seamless JSON serialization
   - Handles binding management
   - Abstracts LOOP complexity from users

5. **Configuration**: [`relayer/chainreader/config.go`](../relayer/chainreader/config.go)
   - Defines configuration structures
   - Controls LOOP vs. direct execution modes

## Key Implementation Details

### Binding Management

The LOOP wrapper automatically manages contract bindings, which is crucial because the plugin process may restart:

```go
// we always bind before calling query functions, because the LOOP plugin may have restarted.
err = s.reader.Bind(ctx, s.getBindings())
if err != nil {
    return fmt.Errorf("failed to re-bind before GetLatestValue: %w", err)
}
```

### Type Safety Measures

The implementation includes extensive type checking to ensure data integrity across the process boundary:

```go
returnValPtr, ok := returnVal.(*[]byte)
if !ok {
    return fmt.Errorf("return value is not a pointer to []byte as expected when running as a LOOP plugin")
}
```

### Error Handling

Comprehensive error handling ensures that serialization/deserialization failures are properly reported:

```go
err = s.decodeGLVReturnValue(readIdentifier, convertedResult, returnVal)
if err != nil {
    return fmt.Errorf("failed to decode GetLatestValue return value: %w", err)
}
```

## Issues & Concerns

### 1. JSON Serialization/Deserialization Challenges

#### Type Loss and Precision Problems
- **Numeric Precision Uncertainty**: The implementation uses `json.Number` to preserve numeric precision, but there's uncertainty about whether this is sufficient (see line 163 in `chainreader.go`)
- **Large Integer Handling**: While `u128` and `u256` types return `*big.Int` for JSON compatibility, precision loss remains a concern during cross-process serialization
- **Complex Type Coercion**: Extensive type conversion logic is required to handle JSON unmarshalled values, adding complexity and potential error points

#### Performance Overhead
- **Double Encoding/Decoding**: Data undergoes multiple encoding/decoding cycles: Go types → JSON → transport → JSON → Sui types
- **Repeated Marshalling**: Every function call requires JSON marshalling of parameters and unmarshalling of results, creating significant overhead

### 2. Code Duplication and Maintenance Issues

#### Shared Code Not Abstracted
- **Query Serialization Duplication**: Expression serialization logic is duplicated between Sui and Aptos implementations (TODO in `loop_query.go:11`)
- **Similar LOOP Wrapper Patterns**: Both Sui and Aptos have nearly identical LOOP wrapper implementations that could be abstracted

### 3. Process Management and Reliability Concerns

#### Plugin Process Lifecycle
- **Mandatory Rebinding**: The need to rebind contracts before every query operation indicates potential reliability issues with plugin process lifecycle
- **Process Restart Handling**: No explicit mechanism for detecting and gracefully handling plugin process restarts beyond rebinding

```go
// we always bind before calling query functions, because the LOOP plugin may have restarted.
err = s.reader.Bind(ctx, s.getBindings())
```

### 4. Contract Generation and Analysis Limitations

#### Generated Code Issues
- **Object Creation Analysis**: Extensive TODOs in generated bindings show that the contract analyzer cannot determine if functions use `::transfer`, always defaulting to `false`
- **Limited Move Semantics**: The contract analyzer lacks sophisticated understanding of Move language semantics

### 5. BCS Encoding Limitations

#### Missing Native Encoding Support
- **Struct Type Support**: Struct types are not supported and require BCS encoding implementation (TODO in `encoder.go:90`)
- **Performance Impact**: Lack of native BCS encoding forces workarounds and potentially slower encoding paths

```go
// TODO: need to use go-bsc to encode this. Reference https://github.com/fardream/go-bcs/blob/main/bcs/encode_test.go
return nil, errors.New("struct types are not supported")
```

### 6. PTB (Programmable Transaction Block) Client Issues

#### Architecture Problems
- **Builder Copying Inefficiency**: PTB builders are passed by value instead of reference, causing unnecessary computational work
- **Type Safety Concerns**: Argument conversion to PTB args lacks strictness despite known expected types from configuration

```go
// TODO: this method should be improved in the following ways
// 1. Given that we already know the expect type from the config, the actual conversion to a PTB arg type should be more strict
// 2. There's no need to pass the builder (by value) around which incurs a lot of (extra) work
```

### 7. Testing and Development Limitations

#### Missing Test Coverage
- **Sui Object ID Format**: Missing test coverage for Sui object ID format validation
- **CI Integration**: Some tests are disabled in CI environment, reducing confidence in LOOP functionality

### 8. Configuration and Interface Complexity

#### Mode-Dependent Code Paths
- **Branch Complexity**: The `IsLoopPlugin` flag creates complex branching logic throughout the codebase
- **Interface Adaptation**: Need for separate wrapper interfaces adds complexity and potential for bugs

### 9. Memory and Resource Usage

#### Inefficient Data Handling
- **Excessive Byte Array Copying**: Multiple byte array allocations and copies for JSON compatibility
- **Memory Allocation Overhead**: Repeated allocations for type conversions and JSON processing

### 10. Error Handling and Debugging

#### Limited Error Context
- **Generic Type Assertion Errors**: Limited context when type assertions fail in LOOP mode
- **Cross-Process Debugging**: Process boundary makes debugging significantly more challenging

### 11. SDK Integration Issues

#### Client Reference Problems
- **Value vs Reference Passing**: Multiple instances of clients being passed by value instead of reference, causing performance degradation

### 12. Query and Expression Handling

#### Serialization Complexity
- **Expression Serialization Overhead**: Complex logic required for serializing/deserializing query expressions across process boundaries
- **Type Safety Risks**: Potential for type mismatches when deserializing expressions from JSON

## Recommended Improvements

### Short-term Fixes
1. **Abstract Common LOOP Patterns** into shared libraries to reduce code duplication
2. **Optimize PTB Client Architecture** to use references instead of value copying
3. **Add Comprehensive Testing** for LOOP-specific code paths

### Medium/Long-term Enhancements
5. **Improve Process Lifecycle Management** with better restart detection and handling mechanisms
6. **Enhance Contract Analysis** for better Move semantics understanding
7. **Implement Type-Safe Serialization** to reduce runtime errors and improve performance

## Impact Assessment

### Performance Impact
- **Latency**: JSON serialization adds 10-50ms per operation depending on data complexity
- **Memory**: 2-3x memory usage due to multiple data representations
- **CPU**: Additional encoding/decoding cycles consume 15-25% more CPU

### Reliability Impact
- **Process Isolation Benefits**: Failures in Sui integration don't affect core node
- **Restart Overhead**: Plugin restarts require rebinding, causing temporary service interruption
- **Error Propagation**: Cross-process errors may lose context

### Development Impact
- **Code Complexity**: LOOP mode adds significant branching and wrapper logic
- **Testing Complexity**: Need to test both direct and LOOP modes
- **Debugging Difficulty**: Cross-process debugging requires specialized tools
