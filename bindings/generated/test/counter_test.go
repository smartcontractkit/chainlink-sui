//go:build integration

package test

import (
	"context"
	"strconv"
	"testing"

	"github.com/pattonkan/sui-go/suiclient"
	"github.com/smartcontractkit/chainlink-common/pkg/logger"

	"github.com/smartcontractkit/chainlink-sui/bindings/bind"
	rel "github.com/smartcontractkit/chainlink-sui/relayer/signer"
	"github.com/smartcontractkit/chainlink-sui/relayer/testutils"

	"github.com/stretchr/testify/require"
)

func setupSuiTest(t *testing.T) (rel.SuiSigner, *suiclient.ClientImpl) {
	t.Helper()

	log := logger.Test(t)

	// Start the node.
	cmd, err := testutils.StartSuiNode(testutils.CLI)
	require.NoError(t, err)
	t.Cleanup(func() {
		if cmd.Process != nil {
			if perr := cmd.Process.Kill(); perr != nil {
				t.Logf("Failed to kill process: %v", perr)
			}
		}
	})

	// Generate key pair and create a signer.
	pk, _, _, err := testutils.GenerateAccountKeyPair(t, log)
	require.NoError(t, err)
	signer := rel.NewPrivateKeySigner(pk)

	// Create the client.
	client := suiclient.NewClient("http://localhost:9000")

	// Fund the account.
	signerAddress, err := signer.GetAddress()
	require.NoError(t, err)
	err = testutils.FundWithFaucet(log, "localnet", signerAddress)
	require.NoError(t, err)

	return signer, client
}

// nolint:tparallel
func TestCounterAutoGenerated(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	signer, client := setupSuiTest(t)

	// Publish the counter contract.
	testPackage, tx, err := PublishTest(ctx, bind.TxOpts{}, signer, *client)
	require.NoError(t, err)
	require.NotNil(t, testPackage)
	require.NotNil(t, tx)

	counter := testPackage.Counter()

	// Retrieve the published counter object's ID.
	counterObjectId, err := bind.FindObjectIdFromPublishTx(tx, "counter", "Counter")
	require.NoError(t, err)

	// nolint:paralleltest
	t.Run("TwoIncrements", func(t *testing.T) {
		// Increment twice.
		increment := counter.Increment(counterObjectId)
		_, err := increment.Execute(ctx, bind.TxOpts{}, signer, *client)
		require.NoError(t, err)
		_, err = increment.Execute(ctx, bind.TxOpts{}, signer, *client)
		require.NoError(t, err)

		// Optionally, inspect the state.
		_, err = counter.GetCount(counterObjectId).Inspect(ctx, bind.TxOpts{}, signer, *client)
		require.NoError(t, err)

		// Read the object and verify that the count is 2.
		obj, err := bind.ReadObject(ctx, counterObjectId, *client)
		require.NoError(t, err)
		count, err := getCount(obj)
		require.NoError(t, err)
		require.Equal(t, uint64(2), count)
	})

	// nolint:paralleltest
	t.Run("IncrementMult", func(t *testing.T) {
		// Call IncrementMult with parameters 4 and 5.
		incrementMult := counter.IncrementMult(counterObjectId, 4, 5)
		_, err := incrementMult.Execute(ctx, bind.TxOpts{}, signer, *client)
		require.NoError(t, err)

		// Read the updated object and verify the expected count (22).
		obj, err := bind.ReadObject(ctx, counterObjectId, *client)
		require.NoError(t, err)
		count, err := getCount(obj)
		require.NoError(t, err)
		require.Equal(t, uint64(22), count)
	})
}

func getCount(obj *suiclient.SuiObjectResponse) (uint64, error) {
	var count string
	err := bind.GetCustomValueFromObjectData(*obj.Data, &count)
	if err != nil {
		return 0, err
	}
	// Convert count string to uint64
	countUint, err := strconv.ParseUint(count, 10, 64)
	if err != nil {
		return 0, err
	}

	return countUint, nil
}
